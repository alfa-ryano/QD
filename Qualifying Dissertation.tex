\documentclass[12pt, a4paper]{report}
\usepackage[titletoc]{appendix}
\usepackage{graphicx}
\graphicspath{{images/}} 
\usepackage{geometry}
 \geometry{a4paper,left=3cm,top=3cm,bottom=3cm,right=3cm}

\usepackage{hyperref}
\hypersetup{colorlinks=true,allcolors=blue}
\usepackage{hypcap}

\setlength{\parindent}{1cm}
\setlength{\parskip}{0.1cm}


\begin{document}


\begin{titlepage}
    \begin{center}

\textbf{Qualifying Dissertation}
\vspace{1cm}

\textbf{\large Gamification of Software Modelling Learning}
\vspace{1cm}

Alfa Ryano Yohannis\\
ary506@york.ac.uk
\vspace{1cm}

Supervisor:\\
Dimitris Kolovos\\
Fiona Polack\\
\vspace{1cm}

Department of Computer Science\\
University of York\\
United Kingdom\\
\vspace{1cm}
\today
        
\vfill
         
\end{center}
\end{titlepage}

\tableofcontents
\addcontentsline{toc}{chapter}{Contents}

\chapter{Abstract}
Software modelling has a fundamental role in software engineering. However, it is perceived as relatively challenging for learners to develop the necessary abstraction skills to master the subject. On the other side, gamification is now flourishing as a popular strategy to engage learners. This research attempts to exploit gameful design as an innovative approach, used to create games that reinforce learners' mastery of software modelling by developing their abstraction skills. Our approach to gameful design brings together gamification development concepts such as the Lens of Intrinsic Skill Atoms, and pedagogical design principles from several learning theories and models. The research follows the Design Science Research Methodology and exploits Model-Driven Engineering best practices. The target outputs of this research are a modelling game design and generation framework, and a number of games produced using it. The effectiveness of the framework and its games will be evaluated using controlled experiments.

\chapter{Introduction}



This research is motivated by the growing attention towards the application of gamification in various fields \cite{kolovos2015eugenia}. Gamification itself is defined as transforming an entity to become more gameful by embedding game-associated characteristics into the entity without losing its original intended functions. The common goal of gamification is improving user’s engagement with the entity through motivating by making the entity more fun. We perceive this as an opportunity to apply gamification as well to software modelling courses. Software modelling is a subject that is seen challenging to students since it requires lots of abstraction. Thus, students who didn’t possess this kind of ability might be hindered and demotivated. Employing gamification is expected will support the students to maintain their engagement along the courses and, therefore, improve their learning outcomes. 

However, in applying the gamification, we faced a challenge that there are only several papers available that discuss the application of game characteristics in software modelling and most of them are still in the preliminary research, covering only small specific topics of software modelling. Modelling, metamodelling, and model management, the core concepts of model-driven software engineering, haven’t been covered yet.  Therefore, we believe that there is a need to extend existing gamification of software modelling works to cover those core concepts as well. The gamification itself is expected can also extend our existing approaches in teaching and learning software modelling. The purpose of this research is to study the gamification of software modelling with emphasis on (1) to what extend gamification improves the learning outcomes of software modelling learning, (2) understanding the process of how gamification improves the learning outcomes, and (3) the design of gamification of software modelling learning manifested in the form of gamification frameworks.

\begin{figure}[ht]
\centering
\includegraphics[width=9cm]{smlg}
\caption{How to 'Cook' a Gameful Software Modelling Learning?}
\label{fig:smlg}
\end{figure}

\begin{figure}[ht]
\centering
\includegraphics[width=9cm]{smlg2}
\caption{Topics the gamification of software modelling learning.}
\label{fig:smlg2}
\end{figure}

We explain the literature review in Section 2 and propose the research proposal in Section 3. In Section 4, we describe the preliminary results. Finally, we end this qualifying dissertation with conclusions in Section 5.


\chapter{Field Survey and Review}

Since the research of the gamification of software modelling learning is multidisciplinary, it’s best to organise the literature review categorised by the contributing fields, including the subtopics resulting from the interaction between them. So far, we have identified three major contributing fields, the software modelling itself, ludology, and pedagogy as well. They will be discussed in the following subsections and a brief review about the research methodology ends this chapter.

\section{Pedagogy}
Designing the gamification of software modelling learning cannot be separated from the field of pedagogy since the core process that will be supported by the gamification is the learning process itself. Pedagogy is a source of knowledge of how we can understand learning processes and drawn principles that will guide the design of the artefact of this research. We have selected several theories and models. They are discussed briefly in the following subsections.

\subsection{Csikszentmihalyi's Flow Theory}
Csikszentmihalyi proposed Flow Theory which states that in order to maintain one's engagement in an activity, the balance between challenges and his capability has to be maintained \cite{csikszentmihalyi2014toward}. Once the challenges are too difficult, he arrives in a state of anxiety that demotivating him and  then force him to withdraw from the activity. On the other side, if the challenges is too easy for him or his skills are very advance, this condition will make him into the state of boredom which also force him not to continue his engagement in the activity.

This theory has been applied in many fields, such as education, training, and games. Specifically for games, flow theory influences the design of levels. The given challenges have to  adjusted so they are balance to the skills of players that improve along playing with games. In the same way, this theory will also influence the design of our game. 

\begin{figure}[ht]
\centering
\includegraphics[width=4cm]{flow-theory}
\caption{Csikszentmihalyi's Flow Theory \cite{csikszentmihalyi2014toward}.}
\label{fig:flow-theory}
\end{figure}
    
\subsection{Zone of Proximal Development/Scaffolding}
Zone of Proximal Develoment (ZPD) was proposed by Lev Vygotsky in the context of adolescent development \cite{vygotsky1978mind}. This term was also called Scaffolding by Wood et al. in the context of learning \cite{wood1976role}. This theory  states that during a learning process, learners have to be reinforced, particularly for knowledge or skills that are too difficult to learn without the support of others, to develop their competence until they are able to acquire the knowledge and skills on their own. 

Software modelling learning game should be designed according to the principle. It should implement  scaffolding, providing helpers and cues to learners to support them solving problems. The scaffolding the will be removed gradually as the competence of the learners grows.   

\begin{figure}[ht]
\centering
\includegraphics[width=6.5cm]{scaffolding}
\caption{Zone of Proximal Development/Scaffolding \cite{vygotsky1978mind},\cite{wood1976role}.}
\label{fig:scaffolding}
\end{figure}

\subsection{Revised Bloom's Taxonomy}
Bloom's Taxonomy \cite{krathwohl2002revision} is a framework of cognitive levels for learning process. The framework has been proven very useful for more than 50 years, all over the world, in supporting educators design learning instructions \cite{munzenmaier2013bloom}. It consists of six activities for students in learning, namely remember, understand, apply, analyse, evaluate, and create, and order them according their cognitive load levels with 'remember' at the bottom and 'create' as the activity that require cognitive load most. 

We see the potential of using the Bloom's Taxonomy activities to design the activities and challenges of learners when playing software modelling learning game. The six activities are the activities that the learners are going to perform when playing the game and the nature of cognitive load of each activity is the challenges of the game. The Bloom's Taxonomy gives us variety of options, activities and challenges, in designing of the levels of our game.

\begin{figure}[ht]
\centering
\includegraphics[width=6cm]{bloom}
\caption{Revised Bloom's Taxonomy\cite{krathwohl2002revision}.}
\label{fig:bloom}
\end{figure}

\subsection{Kolb’s Experiential Learning Model}
Kolb's Experiential Learning Model is a model of teaching and learning through experience and reflection on actions \cite{kolb2014experiential}. It states that knowledge development is a product of experience or iterative search. This model implies that software modelling learning game should allow learners to perform active experimentation and develop their own understanding. 

The model is a cycle of four steps: abstraction conceptualisation, active experimentation, concrete experience, and reflective observation. In the case of didactic learning with practicals, learners are firstly taught about the theory. In this step learners perform abstract conceptualisation. They then move to the practicals which they are asked to perform some active experimentation of the theory they got in the class. Through the experimentation they feel the the concrete experience. The results might be to some degree confirm to or disagree with the theory. In the end, through reflective observation, the results are then reconciled with the knowledge they had built based on the theory, whether the knowledge is updated or not.   

\begin{figure}[ht]
\centering
\includegraphics[width=6cm]{kolb}
\caption{Kolb’s Experiential Learning Model \cite{kolb2014experiential}.}
\label{fig:kolb}
\end{figure}

\subsection{Keller’s ARCS Motivational Learning Model}
Keller's Motivational Model is a set of steps for promoting and maintaining motivation in a learning process \cite{keller2010motivational}. The steps are attention, relevance, confidence, and satisfaction. This model is useful for  designing the flow of a stage or level of a software modelling learning game as it mentions steps that we need to focus in order to maintain learners' motivation.

To maintain the motivation of learners in a process of learning, first, we need to draw the attention of learners using novelty, surprise, aesthetics, or questions. After that, we should explain the relevance of the topic that is about to be explained. We could present the objectives, usefulness, instructions, motives, and contexts. Along the learning process, learners' motivation is maintained by raising the confidence of the learners through presenting their progress, performance, challenge, success, and ability. In the end of the learning process, learners should experience the satisfaction which can be realised by presenting them achievement, enjoyment, rewards, motivation, and feedback.
    
\begin{figure}[ht]
\centering
\includegraphics[width=7cm]{keller}
\caption{Keller's Motivational Model \cite{keller2010motivational}.}
\label{fig:keller}
\end{figure}

\section{Ludology}

\section{Serious Games and Gamification}


\subsection{Hunicke's MDA Model}
Hunicke's MDA Model \cite{hunicke2004mda} consists of three steps in designing a game. They are menchanics, dynamics, and aesthetics. Mechanics means the algorithms and data representation used as the backend of the game. Dynamics is runtime behaviour, mechanics, and player inputs and outputs overtime. It is the interaction between players and the game. Aesthetics is player's emotional responses. Design of a  game has to balance challenges and player's skills to keep the player flowing.

\begin{figure}[ht]
\centering
\includegraphics[width=8cm]{mda}
\caption{Hunicke's MDA Model \cite{hunicke2004mda}.}
\label{fig:mda}
\end{figure}

\subsection{Werbach's Gamification Framework}
Werbach and Hunter proposed a Gamification Framework to guide the implementation of a gamification \cite{werbach2012win}. The framework consist of  a prescriptive model of implementing gamification and a structural model of game element hierachy. The prescriptive model consists of 6D implementation steps, which are (1) Define  business objectives. (2) Delineate target behaviours. (3) Describe your players. (4) Devise activity cycles. (5) Don't forget the fun! (6) Deploy the appropriate tools.

The hierarchy consists of three layers, dynamics, mechanics, and components. Dynamics are the big-picture aspects of the gamified system that one needs to consider and manage but which can never directly present in the system. Mechanics are the basic processes that drive the action forward and generate player engagement. Component are the specific instantiations of mechanics and dynamics. 

\begin{figure}[ht]
\centering
\includegraphics[width=6cm]{werbach}
\caption{Werbach's game element hierarchy \cite{werbach2012win}.}
\label{fig:werbach}
\end{figure}

\subsection{Learning Mechanics-Game Mechanics Model}
Learning Mechanics-Game Mechanics (LMGM) Model consists of 2 sets of mechanics: learning mechanics (LM)  and game menchanics (GM) \cite{arnab2015mapping}. Each mechanics comprises of activities relevant to the aspect that each represents. For examples, modelling, analyse, and discover in LM, and role play, strategy/planning, and selecting/collecting in GM. They act like an inventory which a game designer can select the best mechanics from each mechanics group that fit to a context. The mechanics are then integrated into players' activity cycles.

\begin{figure}[ht]
\centering
\includegraphics[width=12cm]{lmgm}
\caption{Learning Mechanics-Game Mechanics Model \cite{arnab2015mapping}.}
\label{fig:lmgm}
\end{figure}


\section{Software Modelling}

\subsection{What is Software Modelling?}
concretisation
\begin{figure}[ht]
\centering
\includegraphics[width=8cm]{abstraction}
\caption{Abstraction in Model-driven Engineering \cite{brambilla2012model}.}
\label{fig:abstraction}
\end{figure}


\begin{figure}[ht]
\centering
\includegraphics[width=8cm]{concretisation}
\caption{Instantiation in Model-driven Engineering.}
\label{fig:concretisation}
\end{figure}

\subsection{Software Modelling Tools}

\begin{figure}[ht]
\centering
\includegraphics[width=8cm]{epsilon}
\caption{Epsilon is a family of languages and tools for model management\cite{kolovos2015eugenia}.}
\label{fig:epsilon}
\end{figure}



\subsection{Software Modelling Teaching}
We have investigated related literatures regarding the teaching and learning of software modelling.  From the literatures, we have identified lessons and categorised them into 3 groups: contents, teaching or learning practices, and tool design. We will take into account the lessons during the design process of our gamified software modelling learning since we want to develop our research upon other existing works thus have stronger foundation.   

\subsubsection{Contents}
Contents mean the software modelling topics and their structures. In teaching software modelling, we need to teach the core, important concepts and their relation with the contexts and applications of the outside world. The contents of software modelling learning should be:
\begin{enumerate}
\item Software modelling definition \cite{borstler2012teaching}.
\item Semantics, syntaxes, notations. Teach modelling foundations, but focus more on semantics, not only syntax \cite{borstler2012teaching}. Improve use of language, not only vocabulary \cite{bezivin2009teaching}.
\item Modelling, metamodelling, and model transformation. Focus on the core, important concepts: modelling, meta-modelling, and model transformation. Teach modelling that comprise the following topics: formal and informal models, partial and complete models, distinction between models and programs \cite{bezivin2009teaching}. Meta-modelling is given a larger portion than modelling since a model might conforms to more than one meta-mode \cite{ober2007teaching}.
\item Software modelling is engineering. Teach the engineering aspects of software modelling: understanding a domain, planning and resourcing, documentation, quality, formality, validity, optimisation \cite{paige2014bad}.
\item Contexts and practices/applications in various domains \cite{paige2014bad}. Teach the application of software modelling in various domains, success stories, code generations, model discovery, and model-driven interoperability. Make the model executable. Still the power of execution makes it much easier to understand the model \cite{bezivin2009teaching}. Convey the practical applications of modelling \cite{borstler2012teaching}.
\end{enumerate}


\subsubsection{Teaching and Learning Practices}
Teaching and learning practices are the principles, values, and methods in teaching or learning software modelling. The followings are them:
\begin{enumerate}
\item Modelling is the process to think abstractly about systems. Therefore, we teach modelling to make students understand the value of abstraction \cite{bezivin2009teaching}. Successful application of Model-Driven Software Development requires skills in abstract modelling \cite{whittle2013industrial}.
\item Teach with prerequisites \cite{paige2014bad}. Student should have a good programming background \cite{bezivin2009teaching} or has to know a little about OOP \cite{Akayama2013}.
\item Encourage students to produce "good" models, and measure the "quality". One way is to use tools \cite{Akayama2013}.
\item Learn modelling as early as possible \cite{Akayama2013}, \cite{borstler2012teaching}. Teach modelling together with programming (Börstler et al., 2012). Modelling should be developed alongside programming \cite{bezivin2009teaching}.
\item Problem-solving first, modelling language specification and modelling tools get in the way \cite{paige2014bad}.
\item Provide solutions, not answers \cite{paige2014bad}.
\item Teach modelling language broadly, not deeply \cite{paige2014bad}, and throughoutly \cite{borstler2012teaching}). Students need to experience the whole cycle of modelling in a software engineering project so they learn to decide which development process is more appropriate \cite{Akayama2013}.
\item Refer to other disciplines or other aspects related to software modelling \cite{paige2014bad}.
\item Even though code generation is essential to understand modelling \cite{liebel2015ready},  teach other applications (benefits) of software modelling at first. Code generation comes later \cite{paige2014bad}.
\item Be careful when using analogies and physical decomposition, since they might not reflect the complexity of the system; one component might have a cross-cutting effect to other layers of the system \cite{paige2014bad}. 
\item It is good to teach modelling with a standard language, such as UML \cite{bezivin2009teaching}, but teach modelling and meta-modelling using other modelling languages as well, not just UML. Software modelling is not a UML modelling course \cite{paige2014bad}. A significant number of successful Model-driven Software Development companies build their own modeling languages and generators, suggesting a re-orientation of education away from UML notation to fundamental modeling principles \cite{whittle2013industrial}.
\item Choose a playful domain or fun problems, not serious domain \cite{paige2014bad}.
\end{enumerate}

\subsubsection{Tool Design}
Tools design are the principles in designing software modelling tools. Since we are going to develop a tool that can support learners to learn software modelling, lessons in this category will have important in guiding the design of our tool. 
\begin{enumerate}
\item Learning modelling tools is not trivial (Paige et al., 2014). 
\item Build knowledge and skills incrementally \cite{lethbridge2014teaching}.
\item Use papers, tools designed for pedagogy, or use mainstream tools \cite{Akayama2013}.
\item The usage of modelling tools is not important in the beginning, but later when modelling task becomes larger \cite{bezivin2009teaching}.
\item A good experience with the tool has a positive inﬂuence on the students’ view of UML and modelling in general \cite{liebel2015ready}.
\item Support for tool usage greatly affects student satisfaction. Provide Tool Expert and carefully design the instructions if you are using Industry Modelling Tool \cite{liebel2015ready}. For an example, Papyrus is suitable for a classroom environment given the right level of support \cite{liebel2015ready}.
\item Give positive reinforcement to learners \cite{lethbridge2014teaching}.
\item The tools gives maximum opportunities for learning \cite{lethbridge2014teaching}.
\item The tool convinces learners of the value of what they learn \cite{lethbridge2014teaching}.
\item Focus on high usability \cite{lethbridge2014teaching}.
\item The tool is inexpensive \cite{lethbridge2014teaching}.
\end{enumerate}


\subsection{Abstraction in Software Modelling Learning}
Following the last discussion, modelling and meta-modelling, and additionally model management, are the potential concepts that will be taught in the game. All the three concepts requires adequate abstraction skill; a skill that has a fundamental role in Computer Science and Software Engineering (Engels, Hausmann, Lohmann, \& Sauer, 2006; Hazzan, 2008; Kramer \& Hazzan, 2006). 
There are some available strategies in teaching abstraction. Familiarity, Similarity, Reification, Application. This strategy is proposed by White and Mitchelmore in the Math education (White \& Mitchelmore, 2010). They argued that abstraction should be developed from empirical experience, move up to abstraction, and concreting the abstraction through application. Similarly, based on their experience teaching UML, Engels et al. (Engels et al., 2006) approached abstraction through modelling according to this steps: real-word objects, object diagrams, class diagrams. The real-world objects can be described by videos or may be substituted by textual explanation, animations, or pictures. Hazzan (Hazzan, 2008) proposed three methods in teaching abstraction. First, illustrate. Lecturer uses abstraction-related words or statements in teaching. Second, reflect. For an example, lecturer and students question the impact of using certain level of abstraction or not using abstraction at all. Third, practice. Students must practice and reflect on what he do.

There are two approaches of learning software modelling which a learner may perform them simultaneously: rational approach and intuitive approach (Bobkowska, 2014). Usually at the beginning of modelling process, one uses his existing knowledge and logical reasoning to understand and develop software models, and sometimes preceded with empirical activities. However, there are situations in software modelling when his existing knowledge and methodology-based, logical reasoning are not enough to make him understand or to develop a software model. Thus, make him relies on his own intuition or both approaches interplay in dealing with complex, difficult modelling. In line with Bobkowska's statement, in building a model on the correct level of abstraction, one needs a certain intuition and skill which cannot be gain through lectures but have to be experienced through exercises (Engels et al., 2006).

\subsection{Gamified Software Modelling}
Most of the gamification studies available are dominantly relates to software engineering in a larger context or other aspects of software engineering, such as software implementation and project management, rather than software modelling in particular \cite{Pedreira2015}. Several studies that apply gamification specifically for software modelling are the works of Stikkolorum et al. \cite{Stikkolorum2014}, Ionita et al. \cite{Ionita2015}, Groenewegen et al. \cite{Groenewegen2010}, and Richardsen \cite{Richardsen2014}. These works are selected because they develop artefacts based on gamification approach, apply them to software modelling, and validate the results. 

\subsubsection{Puzzle Game to Teach Software Design Principles}
Stikkolorum et al. \cite{Stikkolorum2014} developed a game that is intended to teach software design principles, such as cohesion, coupling, information hiding, and modularity in software design.They tried to look for a solution that provides balance between coupling and cohesion by using the toolbox to draw classes, methods, attributes, and relationships between them. They applied game elements like puzzle game, game levels, visual and audio feedbacks, progress indicator, level unlocking, choice of path, multiple solutions, scoring. For the pedagogical aspect, they mentioned Bloom’s taxonomy in their work. However, they did not explain how they integrated the taxonomy into their work. After using their game, users started to talk regarding classes, methods, and associations instead of boxes, blocks, and lines, indication unconscious learning. The challenges of their work were on determining scores because there are more than one solutions for a problem. To determine coupling, they used Coupling Between Classes (CBO). Cohesion was measured by comparing all items—attributes, methods, class name—in a class that have similar keywords. Information hiding and modularity is evaluated using general design patterns. They validate their design by conducting user test and utilise the 'think aloud' method—asking users to tell their thoughts while using the game. 


\subsubsection{Explorable Board-game to Understand and Validate Enterprise Architecture}
Groenewegen et al. \cite{Groenewegen2010} applied gamification to improve stakeholders' understanding of their enterprise architecture models as well as to validate them.
They employ exploring the model step by step, element by element according to the given rules technique which can provides a player a progressive user experience. Therefore, it can improve user understanding. The game proposed is more playable, more freedom to try and explore, and no explicit rewards given. For the game elements, they utilise cards, explorable board-game, and rules. 
Regardless of their claim that users can understand the model better rather than by merely looking at the model so they can give argument whether the model is valid or not based on their existing knowledge, they never clearly discussed the pedagogical aspect of their work. The challenges that they experienced during the implementation of their are preparing the game by translating implicit knowledge to explicit knowledge of the model—a gap of knowledge between the modeller and the reader, which domain knowledge is required. Lack of domain knowledge will make the model less understandable and the user cannot validate the model. For validation, they tested their work to seven respondents and then interviewing them. 

\subsubsection{Familiar Tangible Model to Model Information Security}
In the domain of information security modelling, Ionita et al.\cite{Ionita2015} developed a socio-technical modelling language (TREsPASS) and map them toward tangible representation. Mapping the socio-technical modelling language to the tangible model is the most challenging part of their work. The tangible representations will increase the familiarity and understandability of models, which will increase awareness, involvement, and learnability. For the game elements, they utilise familiar, tangible representation, such as Lego characters, board-game metaphor, rules. They also discussed the pedagogical aspect of their design which is based on the theory of constructionvism, cognitive load, and cognitive fit. Moreover, based on their experiment, they reported that experimental group performs better than the control group in learnability, efficiency, correctness, and satisfaction. Likewise, based on interview with experts and professionals, the respondents argued that the tangible model might be useful for less technical domain experts and different types of stakeholders to be more participative and contributive in the early stages of architecture modelling.

\subsubsection{Arranging UML Activity Diagram to Control the Behavior of a Game}
In the context of activity diagram learning, Richardsen  \cite{Richardsen2014} developed a game which it's behaviours are controlled through arranging UML activity diagram. Throughout his research, he found challenge that controlling game from activity diagram in Reactive Block Environment (Eclipse based) is difficult since Eclipse is difficult for a first-time user. For validation, he conducted user testing with three users. Think Aloud method was used for observation. After that, questionnaires were given and an interview was conducted. he found out There was no significant different between the traditional interactive tutorial and the game-like tutorial on their performances. However, the game-like tutorial was more engaging. For the validation of his work, he did not mention any explicit pedagogical aspect.\\

Based on the previous four related works, we concluded that different concepts of software modelling were addressed. However, no use of game elements that addresses abstraction regarding modelling, meta-modelling, and model transformation in particular, which mean there is an opportunity for research on that area. We also found that different specific concepts were addressed with different approaches and game elements which also challenge us to develop a more generic design in addressing software modelling learning problem. The good news is all of the works reported that the use of game and game elements has positive effect in motivating and engaging users in varying degree. Furthermore, every study has their own challenges which are a good thing to be aware of when carrying our research. The drawbacks of other works are, first, most of the them did not consider seriously about pedagogical aspect of their solution and, second,in general, their validation was weak regarding sample size and lack discussion of internal validity.


\subsection{Software Modelling Course at the University of York}

\section{Research Methodology}
The software modelling learning game design framework will be derived deductively mainly from existing related theories and research works that come from the fields of education, games, and software modelling. The resulting framework will be tested in several case studies for validation and the test results will be inputs to revise the framework. Since the outputs of the research will be design artefacts, Design Science Research Methodology \cite{peffers2007design} is selected as the research methods as it provides a comprehensive conceptual framework and activity guidelines for understanding, developing, executing, and evaluating design artefacts. We also implements Deterding's Gameful Design Steps \cite{deterding2015lens} to guide the design of the gameful aspect of the the product.

\subsection{Design Science Research Methodology}
We will employ Design Science Research Methodology \cite{peffers2007design} as the methodology to carry out the research. DSRM is selected since it provides a comprehensive conceptual framework consists of activity guidelines for understanding, developing, executing, and evaluating design artefacts. Oher reason is that it positions itself at the top level of abstraction without going into much detail of how to perform each activities, we can freely choose other more concrete research methods to carry out the activities. For examples, we can conduct literature reviews, surveys, or expert interviews to determine research problems, motivations, solutions, and objectives as well as controlled experiments to measure and evaluate the effectiveness of the artefacts. 

\begin{figure}[ht]
\centering
\frame{\includegraphics[width=\textwidth]{dsrm}}
\caption{Design Science Research Methodology. Adapted from Peffer et al. \cite{peffers2007design}.}
\label{fig:003}
\end{figure}

\textbf{Identify Problem and Motivation}. This research will use literature review, suggestions from experts, and surveys to identify research problems and motivations a well as to determine the solution and its objectives.

Based on the literature review, the best guesses that we have made so far regarding the challenges that student has to deal with when learning software modelling are abstracting (choosing the most relevant elements, ignoring the irrelevant ones, and determining the relationships between elements), diagramming (translating the abstraction into visual elements), and determining the algorithmic strategies (programming in the context of model management). Other challenges are no fun (the presentation of the software modelling course is not interesting) and the heavy cognitive loads when dealing with abstract objects. However, the guesses have to be confirmed yet through surveys, drawing information from students of software modelling courses in order for our problem identification to be more accurate.

As we could view the challenges as problems, this research then chooses the problem-centred initiation as its entry point since those challenges hinder learners in learning software modelling.  Grounded on the identified problems, we could decide that there is a necessity to build a tool that can support software modelling students to develop their abstraction, diagramming, and algorithmic strategy skills in a more motivating and engaging way. 

\textbf{Define Objectives of a Solution}. Based on the identified problems and motivations, we have defined our solution that is embedding gamification in the process of software modelling learning, which is expressed by the use of an artefact specifically designed with gamification and pedagogy in mind. The research objectives and outcomes are defined in section 3.2 and 3.3.

\textbf{Design and Development}. This research will employ gameful design method (Deterding, 2015) to design and develop the gamification and agile software development method to design and develop the artefact. The design and development activities are part of the iterative cycles and the products of the activities will be refined as required based the results generated from the evaluation activity.

\textbf{Demonstration and Evaluation}. The resulting artefact will be demonstrated and evaluated by applying it to several courses of software modelling. Moreover, the evaluation results will be used as feedbacks to improve the quality of artefacts and as a ground to judge the research findings.  Demonstration and evaluation activities are parts of the iterative cycles and will be performed again as required. 

\textbf{Communication}. Significant findings will be published in an academic conferences or journals for dissemination and evaluation by the related research communities.


 
\subsection{Gameful Design Method}
Deterding proposed a gameful design method that consists of gameful design steps, a set of design lenses, and skill atoms \cite{deterding2015lens}. Gameful design method is a prescriptive guideline to implement gamification that comprises five phases: strategy, research, synthesis, ideation, and ideation. 

In strategy phase, stakeholder define outcome metrics, target users, context, and activities as well as constraints and requirements. In the next phase, research phase, user activities behaviour chains, user needs, motivations, and hurdles as well as how game design fits with them are identified and defined. After that, in the synthesis phase, triplets or a combination of activity, challenges,  and motivation is defined,including defining skill atoms. Furthermore, in the ideation phase, to generate ideas of the gamification design, brainstorming with innovation stems are conducted. Design lenses are used to help view the triplets from the perspective of game elements. After some ideas are generated, those ideas are prioritised. The prioritised ideas are then translated into storyboards to make them more visible. After that, the ideas are evaluated and refined based on results of the evaluation. In the last phase, a prototype is developed iteratively. This includes the activities of playtesting, analysing, building, and generating new ideas.  

\begin{figure}[ht]
\centering
\includegraphics[width=8cm]{gameful-steps}
\caption{Deterding's gameful design steps \cite{deterding2015lens}.}
\label{fig:gameful-steps}
\end{figure}

Design lenses is a combination of an easy-to-remember name, a short statement of a design principle, and a set of focusing questions that helps designer to view activities, motivation, and challenges from the perspective of the lenses. Design lenses are derived from game elements, so in short, viewing using design lenses means learning to view in the perspective of game elements. Deterding's Design Lenses comes has four categories lenses: challenge, goal and motivation, action and object, and feedback, and each category comes with pre-existing lenses.

\begin{figure}[ht]
\centering
\includegraphics[width=8cm]{lenses}
\caption{Deterding's design lenses \cite{deterding2015lens}.}
\label{fig:lenses}
\end{figure}


A skill atom describes a feedback loop between user and system that is organized around a central challenge or skill: A user takes an action, which forms an input into the system’s rule engine that determines state changes of its tokens, which get put out as feedback to the user, which she integrates into her mental model of the system. Through repeated interaction—multiple run-throughs of the atom—the user masters its skill: training hand–eye coordination, understanding the rules, and so on.

\begin{figure}[ht]
\centering
\includegraphics[width=8cm]{skill-atoms}
\caption{Deterding's skill atoms \cite{deterding2015lens}.}
\label{fig:skill-atoms}
\end{figure}

\chapter{Proposal}
Grounded on the literature review in Chapter 2, we base our research in these premises. First, learning software modelling is not a trivial task as it requires abstraction skills and demands high cognitive loads to deal with abstract objects and operations. Second, regardless gamification design is still an ongoing challenge \cite{Deterding2013}, it is an opportunity for research that up today there is still no work in the gamification of learning that addresses the core concepts of software modelling—modelling, metamodelling, and model transformation. Third, there is still no gamification design framework that guide the integration of game specific domain into software modelling learning. Fourth, opportunity to 

\section{Research Questions}
The main research question proposed by this research is "How can gamification improve software modelling learning?" In order to support answering the main research question, following sub research questions need to be investigated:
\begin{enumerate}
\item Which processes, aspects, principles, or components of software modelling and their teaching and learning practices would benefit from gamification?
\item What types of game elements and in what roles can deliver software modelling learning best? 
\item What kind of orchestrating framework is needed to design the interaction between software modelling and game elements to achieve software modelling gamification?
\item To what extent does gamification of software modelling improve learners' motivation, engagement, and performance?
\item To what extent do software modelling tutors benefit from software modelling game design framework?
\end{enumerate}

\section{Aim and Objectives}
In order to answer the research questions, following aim and objectives should be met. The main aim of this research is to investigate and develop a software modelling game design framework that systematically and semi-automatically drives gamification design to produce software modelling learning games. More precisely, this research aims to meet the following research objectives that are derived from the main research aim:

\begin{enumerate}
\item Perform a literature review and surveys to identify research problems, questions, and objectives as well as necessary information to carry out the selected research methods and to develop an early version of the conceptual framework and artefact as the instantiation of the framework. 
\item Develop a conceptual framework of how to design gamification of software modelling learning based on the literature review and the survey. The framework will be iteratively updated according to the results obtained from the experiments. 
\item Develop a software artefact as the instantiation of the conceptual framework to produce a gamification of software modelling learning. The gamification will be tested to respondents for evaluation and to obtain feedbacks for iterative improvement. 
\item Perform controlled experiments to measure the significance of the sofware modelling learning game in improving learning performance compared to the traditional method.
\item Perform controlled experiments to measure the productivity and maintenabilty of software modelling learning design framework in supporting tutors design and develop gamified software modelling learning. 
\end{enumerate}

\section{Research Outputs}
The potential research outputs of this research are:
\begin{enumerate}
\item Artefact. The software/application of gamification of software modelling learning.
\item Modelling Artefact. A tool for modelling the application of the gamification of software modelling learning.
\item Significance. Controlled experiments, learning outcome comparison between the gamified version and the traditional one.
\item Software Modelling Design Framework. Conceptual and software framework to perform gamification of software modelling learning.
\item Understanding. A model that explains how gamification of software modelling learning works.
This could be achieved through Learning and Game Analytics and Structural Equation Modelling studies.
\item Case Study. Report the application of theories, models, and methods used in this research.
\end{enumerate}

\chapter{Preliminary Results}

\section{Preliminary Survey}
We have conducted our preliminary survey to identify user needs, motivations, and hurdles in order to meet the Research phase of Deterding's gameful steps. This is also inline to the Design Science Research Methodology, which in the first activity we need to identify the problem and motivation so we can define objectives of a solution accurately in the second activity. 

We have distributed online questionnaires to the students of Model Driven Engineering (MoDE) 2015/2016 module. The students were in their Software Engineering master programme at the University of York. From 21 students, only 4 of them completed the questionnaires. The results can be found in Appendix  \autoref{chap:Preliminary Survey Data}.

\section{Requirements}


\section{Game Design}
Gamification has been successfully for a variety of purposes, but there is very little work on software modelling gamification. We wish to assess whether gamification is beneficial for learners of graphical software modelling languages. For each modelling language, we envision the development of a dedicated game containing game elements that will be derived from the Lens of Intrinsic Skill Atoms \cite{deterding2015lens}. The generated game will mimic a graphical modelling tool and at each level, it will require the learner to graphically construct or adapt a model to satisfy a set of requirements and constraints.
	1
The game will have levels with gradually increasing difficulty as well as variety in its challenges, to expose learners to different kinds of domains, models, and diagrams. Tutorials are planned to be embedded into the game to help learners familiarise themselves with the control system and the flow of the game. 

The game will include interim goals and intrinsic rewards to motivate learners. For software modelling, each type of modelling (e.g. object modelling, collaboration, process) will have several stories. A story will represent a specific case study to introduce learners to problems in specific domains. Every story will consist of several levels, and every level will have one or more objectives that a learner needs to accomplish to complete it. A level may also be a continuation of a previous level, giving the learner a sense of step-by-step progress to complete the domain problems. Each story and level will introduce new concepts and link them with previously introduced concepts.

A real-world problem can be very complex and time-consuming to model. Thus, the extraneous activities that are not relevant to the core concepts that are being taught should be removed. As a result, learners will be more focused on the main concepts. Thus, game elements like bite-sized actions (e.g. drag and drop), limited choices (i.e. only limited items can be dragged), and microflows (i.e. put the right element to its right place) will be implemented to facilitate learners in performing the core activities. Likewise, fuzziness will also be used to provoke learners' creativity since most of the time there is no single correct model for the problem at hand. Attractive design will also be significant to motivate learners to interact with the game. Games should be able to give immediate, glanceable, and actionable feedback to keep learners on track and monitor their progress. Interesting and varied feedback should be designed to appeal to the learners' motives. 

To reduce bias, we plan to experiment with several modelling languages (e.g. BPMN, state-charts, GSN, UML). We also plan to implement these games using web technologies so that they are easily accessible to a wide audience.

\begin{figure}[ht]
\centering
\frame{\includegraphics[width=\textwidth]{game-annotated}}
\caption{The display of the generated game.}
\label{fig:001}
\end{figure}

\section{Modelling Game Design Framework}
Instead of developing the software modelling games manually, we plan to follow a model-based approach. We will use metamodel annotations, in the spirit of Eugenia \cite{kolovos2015eugenia}, to define the graphical syntaxes of modelling languages and separate models to specify the game elements (levels, objectives, constraints, etc.) of each game. These models will be then consumed by a model-to-text transformation to produce fully-functional language-specific games. Therefore, the framework supports software modelling tutors in the design and customisation of the games at the high level of abstraction and so as to automatically build the game. So far we have implemented a metamodel for specifying game elements (flows, levels, challenges, and objectives) and a supporting Eclipse-based graphical editor (Fig. \ref{fig:002}), and a prototype game (Fig. \ref{fig:001}) for object diagrams. 

\begin{figure}[ht]
\centering
\frame{\includegraphics[width=\textwidth]{editor}}
\caption{Graphical editor for the game specification DSL.}
\label{fig:002}
\end{figure}



\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{IEEEtran}
\bibliography{references}

\begin{appendices}

\chapter{Research Plan}
The planned research schedule can be found in Table 1. In three years, this work plans to have five times iteration of Design-Develop-Demonstration-Evaluation, with two of them will be carry out in Indonesia and the rest of them in York.

\begin {table}[ht]
\caption {Research Timetable} 
\end{table}
\begin{figure}[ht]
\centering
\includegraphics[width=\textwidth]{timetable}
\end{figure}

\chapter{Publications}
This research has been published in the following conferences or journals: 
\begin{enumerate}
  \item  A. Yohannis, “Gamiﬁcation of software modelling,” in the ACM/IEEE 19th International Con-
ference on Model Driven Engineering Languages and Systems (MODELS 2016) Doctoral Sym-
posium. CEUR, 2016 \cite{Yohannis2016}.
\end{enumerate}

\chapter{Preliminary Survey Data}
\label{chap:Preliminary Survey Data}

\begin{enumerate}
\item  \textbf{If you think back to the time when you were just about to start the MODE module, what did you think you would find interesting in Model ­Driven Engineering?}
\begin{itemize}
\item Learning what MDE actually is. Had never heard of it so was intrigued.
\item I thought I would be provided with a high level approach to designing and managing software/critical systems.
\item Learning some tools to create auto­models.
\item Learning about ways of statically verifying that code conformed to a formal model, and using this to detect and/or automatically correct bugs learning about ways to automatically modify code based on changes made to a model.
\end{itemize}

\item  \textbf{What did you find important in Model­ Driven Engineering?}
\begin{itemize}
\item Domain modelling ­ especially metamodels and the whole concept of abstract syntax. In terms of practicalities, the ability to use models to generate code is the most useful, along with creating DSLs.
\item Trying to learn the specific tools to pass the assessment. Not ideal as I wanted more generic
skillsets in this domain I could apply in my career, instead it was too focused on learning some niche features in Epsilon.
\item abstract thinking ­ validate the models ­ linking the model to real­life.
\item The ability to keep a formal model that the code has been verified to conform to throughout
an entire development process Automatic code generationmodifcation based on a model.
\end{itemize}

\item  \textbf{ Why did you decide to take the Model ­Driven Engineering module?}
\begin{itemize}
\item It was compulsory. I had no choice.
\item Compulsory.
\item well, I feel that everything around me has a certain model, therefore, i felt learning about. Model­ Driven will increase my knowledge and experience in work. 
\item It seemed like it would be useful to learn a new approach to software engineering and skills that might be valuable in industry in the future I was interested in generating and transforming code automatically and using a formal model for the structure of code.
\end{itemize}


\item  \textbf{ What would motivate you more to learn Model Driven Engineering?}
\begin{itemize}
\item Seeing the MDE approach being used to do something that would otherwise be much more tedious to do using more conventional means.
\item To see the benfit applied in the real world and how organisations have benefited from it. Then how can use these skills and adapt them to my needs.
\item If we link it to real­life examples, explore more other tools.
\item More use of it in industry More use with languages other than java and different types of models such as ones that aren't based on UML/EMF.
\end{itemize}

\item  \textbf{ Based on the answers that you’ve provided above (No. 1­4), what were the most basic, core underlying motives or needs that make you commit to learning Model­
Driven Engineering?}

\begin{itemize}
\item The ability to think at a higher level of abstraction and understand the concepts which link together a domain ­ especially, for example, programming languages. 
\item Passing the compulsory paper.
\item see some real­life examples and apply different models to see the differences. 
\item Learning skills which would be valuable in the SE industry in the future Learning something which would help with controlling the complexity of a SE process by making sure that code
conforms to a formally­defined model
\end{itemize}


\item  \textbf{ What were the challenges that you found interesting in learning Model­Driven Engineering? Why?}
\begin{itemize}
\item One of the main challenges is in defining the abstract syntax for a DSL along with placing restrictions on its use through a validation language. There's a balance between trying to make the abstract syntax clean and easy to understand and modify vs. preserving the intended semantics.
\item None really, I found the assignment and practicals a tool based grind as opposed to a useful learning opportunity.
\item I felt sometimes that I could not apply all principles in the practicals­ especially on how we think abstract.
\item Working out how to best model a system, which had been defined informally, in EMF and EVL while keeping all its constraints intact and making it easily queryable and transformable was interesting.
\end{itemize}


\item  \textbf{How did you manage to overcome these challenges?}
\begin{itemize}
\item By experimenting and going with what makes the most sense. If it's a structural issue with semantics, it's an abstract syntax issue. If it's something more peculiar, it's a validation issue.
\item By grinding through them.
\item I tried to train myself on other examples, but still I could not link my models to real­life example( as real project). 
\item The best way to learn this was from experience which was gained by completing all the practicals.
\end{itemize}


\item  \textbf{ What were the hurdles--the non­interesting challenges--that hindered or demotivated you in learning Model­Driven Engineering? Why?}
\begin{itemize}
\item Learning the Eclipse Modelling Framework, MOF etc. wasn't fun. The most fun part was learning and use Emfatic with EGL/EGX and EOL in general. But actually understanding the meta­metamodel and all the ecore stuff seemed pointless. You don't need to understand what EClass, EEnum, EString etc. are. It's just unnecessary detail that's very specific to
Eclipse and not really something that you need to know even if you use Epsilon.
\item The focus on the tool as opposed to the high level concepts and skill sets that would empower me to utilise model driven engineering in the real world.
\item sometime the tool itself, you need to re­track all your changes manually, no right answer or a good explanation why this model is good or bad.
\item Problems using eclipse, the shortcomings of EMF, lack of information available on the internet Eclipse is very large, complex and fragile. EMF/ UML ­style models can be quite restrictive at times when modelling complex relationships, and often requires resorting to EVL. This is annoying because EVL constraints cannot be easily displayed on a diagram and two different languages/systems, EVL and EMF, are being used for similar things. Sometimes two very similar constraints exist where one can be modeled in EMF and the
other can't and so requires EVL. Although there is a lot of very good documentation available about the languages in epsilon there is far less information on the internet about them than what is usually available for popular programming languages and it qould be helpful if there was more.
\end{itemize}

\item  \textbf{How did you overcome these hurdles?}
\begin{itemize}
\item By ignoring them; once I realized they served no purpose for developers.
\item Reading up about the tools and grinding through them.
\item Asking questions, reading some examples in the Epsilon website forum.
\item Eclipse sometimes stops working but does this usually does not prevent the completion of tasks as most problems can be fixed by deleting the workspace directory and starting again, it simply wastes a lot of time Things that could not be expressed in EMF were instead expressed using EVL. The required information about epsilon could always be found by
asking classmates and asking lecturers, but this would not be possible if using these languages outside the university
\end{itemize}


\end{enumerate}

\end{appendices}

\end{document}
